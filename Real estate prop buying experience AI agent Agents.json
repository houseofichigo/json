{
  "nodes": [
    {
      "id": "seqStart_0",
      "position": {
        "x": 898.8354733301901,
        "y": 405.7961321328909
      },
      "type": "customNode",
      "data": {
        "id": "seqStart_0",
        "label": "Start",
        "version": 2,
        "name": "seqStart",
        "type": "Start",
        "baseClasses": [
          "Start"
        ],
        "category": "Sequential Agents",
        "description": "Starting point of the conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "description": "Only compatible with models that are capable of function calling: ChatOpenAI, ChatMistral, ChatAnthropic, ChatGoogleGenerativeAI, ChatVertexAI, GroqChat",
            "id": "seqStart_0-input-model-BaseChatModel"
          },
          {
            "label": "Agent Memory",
            "name": "agentMemory",
            "type": "BaseCheckpointSaver",
            "description": "Save the state of the agent",
            "optional": true,
            "id": "seqStart_0-input-agentMemory-BaseCheckpointSaver"
          },
          {
            "label": "State",
            "name": "state",
            "type": "State",
            "description": "State is an object that is updated by nodes in the graph, passing from one node to another. By default, state contains \"messages\" that got updated with each message sent and received.",
            "optional": true,
            "id": "seqStart_0-input-state-State"
          },
          {
            "label": "Input Moderation",
            "description": "Detect text that could generate harmful output and prevent it from being sent to the language model",
            "name": "inputModeration",
            "type": "Moderation",
            "optional": true,
            "list": true,
            "id": "seqStart_0-input-inputModeration-Moderation"
          }
        ],
        "inputs": {
          "model": "{{chatOpenAI_0.data.instance}}",
          "agentMemory": "{{mySQLAgentMemory_0.data.instance}}",
          "state": "{{seqState_0.data.instance}}",
          "inputModeration": ""
        },
        "outputAnchors": [
          {
            "id": "seqStart_0-output-seqStart-Start",
            "name": "seqStart",
            "label": "Start",
            "description": "Starting point of the conversation",
            "type": "Start"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 383,
      "selected": false,
      "positionAbsolute": {
        "x": 898.8354733301901,
        "y": 405.7961321328909
      },
      "dragging": false
    },
    {
      "id": "chatOpenAI_0",
      "position": {
        "x": 550.8267209086752,
        "y": 285.45665699647907
      },
      "type": "customNode",
      "data": {
        "id": "chatOpenAI_0",
        "label": "ChatOpenAI",
        "version": 8,
        "name": "chatOpenAI",
        "type": "ChatOpenAI",
        "baseClasses": [
          "ChatOpenAI",
          "BaseChatModel",
          "BaseLanguageModel",
          "Runnable"
        ],
        "category": "Chat Models",
        "description": "Wrapper around OpenAI large language models that use the Chat endpoint",
        "inputParams": [
          {
            "label": "Connect Credential",
            "name": "credential",
            "type": "credential",
            "credentialNames": [
              "openAIApi"
            ],
            "id": "chatOpenAI_0-input-credential-credential"
          },
          {
            "label": "Model Name",
            "name": "modelName",
            "type": "asyncOptions",
            "loadMethod": "listModels",
            "default": "gpt-4o-mini",
            "id": "chatOpenAI_0-input-modelName-asyncOptions"
          },
          {
            "label": "Temperature",
            "name": "temperature",
            "type": "number",
            "step": 0.1,
            "default": 0.9,
            "optional": true,
            "id": "chatOpenAI_0-input-temperature-number"
          },
          {
            "label": "Streaming",
            "name": "streaming",
            "type": "boolean",
            "default": true,
            "optional": true,
            "additionalParams": true,
            "id": "chatOpenAI_0-input-streaming-boolean"
          },
          {
            "label": "Max Tokens",
            "name": "maxTokens",
            "type": "number",
            "step": 1,
            "optional": true,
            "additionalParams": true,
            "id": "chatOpenAI_0-input-maxTokens-number"
          },
          {
            "label": "Top Probability",
            "name": "topP",
            "type": "number",
            "step": 0.1,
            "optional": true,
            "additionalParams": true,
            "id": "chatOpenAI_0-input-topP-number"
          },
          {
            "label": "Frequency Penalty",
            "name": "frequencyPenalty",
            "type": "number",
            "step": 0.1,
            "optional": true,
            "additionalParams": true,
            "id": "chatOpenAI_0-input-frequencyPenalty-number"
          },
          {
            "label": "Presence Penalty",
            "name": "presencePenalty",
            "type": "number",
            "step": 0.1,
            "optional": true,
            "additionalParams": true,
            "id": "chatOpenAI_0-input-presencePenalty-number"
          },
          {
            "label": "Timeout",
            "name": "timeout",
            "type": "number",
            "step": 1,
            "optional": true,
            "additionalParams": true,
            "id": "chatOpenAI_0-input-timeout-number"
          },
          {
            "label": "BasePath",
            "name": "basepath",
            "type": "string",
            "optional": true,
            "additionalParams": true,
            "id": "chatOpenAI_0-input-basepath-string"
          },
          {
            "label": "Proxy Url",
            "name": "proxyUrl",
            "type": "string",
            "optional": true,
            "additionalParams": true,
            "id": "chatOpenAI_0-input-proxyUrl-string"
          },
          {
            "label": "Stop Sequence",
            "name": "stopSequence",
            "type": "string",
            "rows": 4,
            "optional": true,
            "description": "List of stop words to use when generating. Use comma to separate multiple stop words.",
            "additionalParams": true,
            "id": "chatOpenAI_0-input-stopSequence-string"
          },
          {
            "label": "BaseOptions",
            "name": "baseOptions",
            "type": "json",
            "optional": true,
            "additionalParams": true,
            "id": "chatOpenAI_0-input-baseOptions-json"
          },
          {
            "label": "Allow Image Uploads",
            "name": "allowImageUploads",
            "type": "boolean",
            "description": "Allow image input. Refer to the <a href=\"https://docs.flowiseai.com/using-flowise/uploads#image\" target=\"_blank\">docs</a> for more details.",
            "default": false,
            "optional": true,
            "id": "chatOpenAI_0-input-allowImageUploads-boolean"
          },
          {
            "label": "Image Resolution",
            "description": "This parameter controls the resolution in which the model views the image.",
            "name": "imageResolution",
            "type": "options",
            "options": [
              {
                "label": "Low",
                "name": "low"
              },
              {
                "label": "High",
                "name": "high"
              },
              {
                "label": "Auto",
                "name": "auto"
              }
            ],
            "default": "low",
            "optional": false,
            "additionalParams": true,
            "id": "chatOpenAI_0-input-imageResolution-options"
          }
        ],
        "inputAnchors": [
          {
            "label": "Cache",
            "name": "cache",
            "type": "BaseCache",
            "optional": true,
            "id": "chatOpenAI_0-input-cache-BaseCache"
          }
        ],
        "inputs": {
          "cache": "",
          "modelName": "gpt-4o-mini",
          "temperature": "0.7",
          "streaming": true,
          "maxTokens": "",
          "topP": "",
          "frequencyPenalty": "",
          "presencePenalty": "",
          "timeout": "",
          "basepath": "",
          "proxyUrl": "",
          "stopSequence": "",
          "baseOptions": "",
          "allowImageUploads": "",
          "imageResolution": "low"
        },
        "outputAnchors": [
          {
            "id": "chatOpenAI_0-output-chatOpenAI-ChatOpenAI|BaseChatModel|BaseLanguageModel|Runnable",
            "name": "chatOpenAI",
            "label": "ChatOpenAI",
            "description": "Wrapper around OpenAI large language models that use the Chat endpoint",
            "type": "ChatOpenAI | BaseChatModel | BaseLanguageModel | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 670,
      "selected": false,
      "positionAbsolute": {
        "x": 550.8267209086752,
        "y": 285.45665699647907
      },
      "dragging": false
    },
    {
      "id": "seqState_0",
      "position": {
        "x": 897.5237647884551,
        "y": 807.0153859372136
      },
      "type": "customNode",
      "data": {
        "id": "seqState_0",
        "label": "State",
        "version": 2,
        "name": "seqState",
        "type": "State",
        "baseClasses": [
          "State"
        ],
        "category": "Sequential Agents",
        "description": "A centralized state object, updated by nodes in the graph, passing from one node to another",
        "inputParams": [
          {
            "label": "Custom State",
            "name": "stateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedStateTab",
            "additionalParams": true,
            "default": "stateMemoryUI",
            "tabs": [
              {
                "label": "Custom State (Table)",
                "name": "stateMemoryUI",
                "type": "datagrid",
                "description": "Structure for state. By default, state contains \"messages\" that got updated with each message sent and received.",
                "hint": {
                  "label": "How to use",
                  "value": "\nSpecify the Key, Operation Type, and Default Value for the state object. The Operation Type can be either \"Replace\" or \"Append\".\n\n**Replace**\n- Replace the existing value with the new value.\n- If the new value is null, the existing value will be retained.\n\n**Append**\n- Append the new value to the existing value.\n- Default value can be empty or an array. Ex: [\"a\", \"b\"]\n- Final value is an array.\n"
                },
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "editable": true
                  },
                  {
                    "field": "type",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Replace",
                      "Append"
                    ],
                    "editable": true
                  },
                  {
                    "field": "defaultValue",
                    "headerName": "Default Value",
                    "flex": 1,
                    "editable": true
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Custom State (Code)",
                "name": "stateMemoryCode",
                "type": "code",
                "description": "JSON object representing the state",
                "hideCodeExecute": true,
                "codeExample": "{\n    aggregate: {\n        value: (x, y) => x.concat(y), // here we append the new message to the existing messages\n        default: () => []\n    }\n}",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqState_0-input-stateMemory-tabs"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "stateMemory": "stateMemoryUI",
          "stateMemoryUI": "[{\"key\":\"listing_info\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":0}]",
          "selectedStateTab_seqState_0": "stateMemoryUI",
          "stateMemoryCode": ""
        },
        "outputAnchors": [
          {
            "id": "seqState_0-output-seqState-State",
            "name": "seqState",
            "label": "State",
            "description": "A centralized state object, updated by nodes in the graph, passing from one node to another",
            "type": "State"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 253,
      "selected": false,
      "positionAbsolute": {
        "x": 897.5237647884551,
        "y": 807.0153859372136
      },
      "dragging": false
    },
    {
      "id": "mySQLAgentMemory_0",
      "position": {
        "x": 546.9114586346391,
        "y": 984.8136733823817
      },
      "type": "customNode",
      "data": {
        "id": "mySQLAgentMemory_0",
        "label": "MySQL Agent Memory",
        "version": 1,
        "name": "mySQLAgentMemory",
        "type": "AgentMemory",
        "baseClasses": [
          "AgentMemory",
          "BaseCheckpointSaver"
        ],
        "category": "Memory",
        "description": "Memory for agentflow to remember the state of the conversation using MySQL database",
        "inputParams": [
          {
            "label": "Connect Credential",
            "name": "credential",
            "type": "credential",
            "credentialNames": [
              "MySQLApi"
            ],
            "optional": true,
            "id": "mySQLAgentMemory_0-input-credential-credential"
          },
          {
            "label": "Host",
            "name": "host",
            "type": "string",
            "id": "mySQLAgentMemory_0-input-host-string"
          },
          {
            "label": "Database",
            "name": "database",
            "type": "string",
            "id": "mySQLAgentMemory_0-input-database-string"
          },
          {
            "label": "Port",
            "name": "port",
            "type": "number",
            "default": "3306",
            "id": "mySQLAgentMemory_0-input-port-number"
          },
          {
            "label": "Additional Connection Configuration",
            "name": "additionalConfig",
            "type": "json",
            "additionalParams": true,
            "optional": true,
            "id": "mySQLAgentMemory_0-input-additionalConfig-json"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "host": "localhost",
          "database": "flowise-local",
          "port": "3306",
          "additionalConfig": ""
        },
        "outputAnchors": [
          {
            "id": "mySQLAgentMemory_0-output-mySQLAgentMemory-AgentMemory|BaseCheckpointSaver",
            "name": "mySQLAgentMemory",
            "label": "AgentMemory",
            "description": "Memory for agentflow to remember the state of the conversation using MySQL database",
            "type": "AgentMemory | BaseCheckpointSaver"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 625,
      "selected": false,
      "positionAbsolute": {
        "x": 546.9114586346391,
        "y": 984.8136733823817
      },
      "dragging": false
    },
    {
      "id": "seqConditionAgent_0",
      "position": {
        "x": 1250.7095841435578,
        "y": 283.31163770580815
      },
      "type": "customNode",
      "data": {
        "id": "seqConditionAgent_0",
        "label": "Condition Agent",
        "version": 3,
        "name": "seqConditionAgent",
        "type": "ConditionAgent",
        "baseClasses": [
          "ConditionAgent"
        ],
        "category": "Sequential Agents",
        "description": "Uses an agent to determine which route to take next",
        "inputParams": [
          {
            "label": "Name",
            "name": "conditionAgentName",
            "type": "string",
            "placeholder": "Condition Agent",
            "id": "seqConditionAgent_0-input-conditionAgentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "default": "You are an expert customer support routing system.\nYour job is to detect whether a customer support representative is routing a user to the technical support team, or just responding conversationally.",
            "additionalParams": true,
            "optional": true,
            "id": "seqConditionAgent_0-input-systemMessagePrompt-string"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and Human Prompt.",
            "additionalParams": true,
            "id": "seqConditionAgent_0-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "default": "The previous conversation is an interaction between a customer support representative and a user.\nExtract whether the representative is routing the user to the technical support team, or just responding conversationally.\n\nIf representative want to route the user to the technical support team, respond only with the word \"TECHNICAL\".\nOtherwise, respond only with the word \"CONVERSATION\".\n\nRemember, only respond with one of the above words.",
            "additionalParams": true,
            "optional": true,
            "id": "seqConditionAgent_0-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqConditionAgent_0-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "conditionAgentStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqConditionAgent_0-input-conditionAgentStructuredOutput-datagrid"
          },
          {
            "label": "Condition",
            "name": "condition",
            "type": "conditionFunction",
            "tabIdentifier": "selectedConditionFunctionTab",
            "tabs": [
              {
                "label": "Condition (Table)",
                "name": "conditionUI",
                "type": "datagrid",
                "description": "If a condition is met, the node connected to the respective output will be executed",
                "optional": true,
                "datagrid": [
                  {
                    "field": "variable",
                    "headerName": "Variable",
                    "type": "freeSolo",
                    "editable": true,
                    "loadMethod": [
                      "getPreviousMessages",
                      "loadStateKeys"
                    ],
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Agent's JSON Key Output (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Total Messages (number)",
                        "value": "$flow.state.messages.length"
                      },
                      {
                        "label": "First Message Content (string)",
                        "value": "$flow.state.messages[0].content"
                      },
                      {
                        "label": "Last Message Content (string)",
                        "value": "$flow.state.messages[-1].content"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      }
                    ],
                    "flex": 0.5,
                    "minWidth": 200
                  },
                  {
                    "field": "operation",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Contains",
                      "Not Contains",
                      "Start With",
                      "End With",
                      "Is",
                      "Is Not",
                      "Is Empty",
                      "Is Not Empty",
                      "Greater Than",
                      "Less Than",
                      "Equal To",
                      "Not Equal To",
                      "Greater Than or Equal To",
                      "Less Than or Equal To"
                    ],
                    "editable": true,
                    "flex": 0.4,
                    "minWidth": 150
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "flex": 1,
                    "editable": true
                  },
                  {
                    "field": "output",
                    "headerName": "Output Name",
                    "editable": true,
                    "flex": 0.3,
                    "minWidth": 150
                  }
                ]
              },
              {
                "label": "Condition (Code)",
                "name": "conditionFunction",
                "type": "code",
                "description": "Function to evaluate the condition",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Must return a string value at the end of function. For example:\n    ```js\n    if (\"X\" === \"X\") {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n2. In most cases, you would probably get the last message to do some comparison. You can get all current messages from the state: `$flow.state.messages`:\n    ```json\n    [\n        {\n            \"content\": \"Hello! How can I assist you today?\",\n            \"name\": \"\",\n            \"additional_kwargs\": {},\n            \"response_metadata\": {},\n            \"tool_calls\": [],\n            \"invalid_tool_calls\": [],\n            \"usage_metadata\": {}\n        }\n    ]\n    ```\n\n    For example, to get the last message content:\n    ```js\n    const messages = $flow.state.messages;\n    const lastMessage = messages[messages.length - 1];\n\n    // Proceed to do something with the last message content\n    ```\n\n3. If you want to use the Condition Agent's output for conditional checks, it is available as `$flow.output` with the following structure:\n\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, we can check if the agent's output contains specific keyword:\n    ```js\n    const result = $flow.output.content;\n    \n    if (result.includes(\"some-keyword\")) {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n    If Structured Output is enabled, `$flow.output` will be in the JSON format as defined in the Structured Output configuration:\n    ```json\n    {\n        \"foo\": 'var'\n    }\n    ```\n\n4. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n5. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output.content;\n\nif (result.includes(\"some-keyword\")) {\n    return \"Agent\";\n}\n\nreturn \"End\";\n",
                "optional": true
              }
            ],
            "id": "seqConditionAgent_0-input-condition-conditionFunction"
          }
        ],
        "inputAnchors": [
          {
            "label": "Start | Agent | LLM | Tool Node",
            "name": "sequentialNode",
            "type": "Start | Agent | LLMNode | ToolNode",
            "list": true,
            "id": "seqConditionAgent_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqConditionAgent_0-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "conditionAgentName": "router",
          "sequentialNode": [
            "{{seqStart_0.data.instance}}"
          ],
          "model": "",
          "systemMessagePrompt": "You are an expert real estate routing system.\nYour job is to detect whether a representative is routing a user to the listing details team, lead capture team, payment calculation team or just responding conversationally.",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "The previous conversation is an interaction between a real estate representative and a user.\n\n- If user wants to know about the property listing, price, location or any other details except EMI or monthly payments, route the user to listing details team\n- If user wants to contact or get in touch or interested in listing, then route them to lead capture team\n- If user wants to know monthly payment(EMI) calculation, then route them to payment calculation team\n\nIf representative want to route the user to... \n- listing details team, respond only with the word \"LISTING DETAILS\".\n- lead capture team, respond only with the word \"LEAD CAPTURE\".\n- payment calculation team, respond only with the word \"PAYMENT CALCULATION\".\n- otherwise, just respond with the word \"CONVERSATION\".\n\nRemember, only respond with one of the above words.",
          "promptValues": "{\"email\":\"$flow.state.email\",\"name\":\"$flow.state.name\"}",
          "conditionAgentStructuredOutput": "",
          "condition": "",
          "conditionUI": "[{\"variable\":\"$flow.output.content\",\"operation\":\"Is\",\"value\":\"LISTING DETAILS\",\"output\":\"LISTING DETAILS\",\"actions\":\"\",\"id\":0},{\"variable\":\"$flow.output.content\",\"operation\":\"Is\",\"value\":\"LEAD CAPTURE\",\"output\":\"LEAD CAPTURE\",\"actions\":\"\",\"id\":1},{\"variable\":\"$flow.output.content\",\"operation\":\"Is\",\"value\":\"PAYMENT CALCULATION\",\"output\":\"PAYMENT CALCULATION\",\"actions\":\"\",\"id\":2}]",
          "selectedConditionFunctionTab_seqConditionAgent_0": "conditionUI"
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "options": [
              {
                "id": "seqConditionAgent_0-output-end-Condition",
                "name": "end",
                "label": "End",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqConditionAgent_0-output-leadCapture-Condition",
                "name": "leadCapture",
                "label": "LEAD CAPTURE",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqConditionAgent_0-output-listingDetails-Condition",
                "name": "listingDetails",
                "label": "LISTING DETAILS",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqConditionAgent_0-output-paymentCalculation-Condition",
                "name": "paymentCalculation",
                "label": "PAYMENT CALCULATION",
                "type": "Condition",
                "isAnchor": true
              }
            ]
          }
        ],
        "outputs": {
          "output": "next"
        },
        "selected": false
      },
      "width": 300,
      "height": 680,
      "selected": false,
      "positionAbsolute": {
        "x": 1250.7095841435578,
        "y": 283.31163770580815
      },
      "dragging": false
    },
    {
      "id": "seqAgent_0",
      "position": {
        "x": 1716.1824969880054,
        "y": -423.04930091714215
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_0",
        "label": "Agent",
        "version": 4,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_0-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_0-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_0-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_0-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_0-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_0-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_0-input-tools-Tool"
          },
          {
            "label": "Start | Agent | Condition | LLM | Tool Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode",
            "list": true,
            "id": "seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_0-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "listing_details",
          "systemMessagePrompt": "You are a real estate assistant working for \"ABC Realty\" specializing in providing accurate, related, short and crisp information about this specific property listing.\n\nWhen interacting with users:\n- Understand the User's Query: Focus on understanding the specific details or questions the user is asking about the property listing (e.g., pricing, location, features, or availability).\n- Retrieve Relevant Data: If the user does not provide listing details, use the external database/tool to retrieve accurate and up-to-date information about the property.\n- Respond Accurately: Avoid listing unrelated details or overwhelming the user with unnecessary information.\n- Clarity and Precision: Structure your responses clearly and concisely, directly addressing the user's question while ensuring the response is related and easy to understand.\n- Unavailable Information: If certain information is unavailable, politely inform the user and suggest user to share their name, email. So that they can be contacted by the customer relationship team.\n- If specific data is unavailable or listed as 'None,' rephrase the response to avoid redundancy or awkward phrasing. For example:\nInstead of: \"The property does not have any water facilities available, as the water source is listed as 'None.'\"\nSay: \"This property does not have water facilities available.\"\n- Avoid repeating null/none values or database terms directly in the response.\n- Avoid using sentences like \"If you have any other questions or need more details, feel free to ask!\" too much.\n\nExample Interaction:\nUser Query: \"What are the features of this property?\"\nYour Response: \"This property features 3 bedrooms, 2 bathrooms, a modern kitchen, a spacious backyard, and a two-car garage.\"\n\nAlways prioritize accuracy, relevance, and user-friendliness in your responses. Do not provide information outside the scope of the property listing or the user's query.\n\n",
          "messageHistory": "",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "{listing_details}",
          "tools": [
            "{{customTool_0.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqConditionAgent_0.data.instance}}",
            "{{seqConditionAgent_0.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "{\"listing_details\":\"$flow.state.listing_info\"}",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": "",
          "selectedUpdateStateMemoryTab_seqAgent_0": "updateStateMemoryCode",
          "updateStateMemoryCode": "const isToolsUsed = $flow.output.usedTools?.length\nif(!isToolsUsed){\n  return {}\n}\n\nconst toolOutput = $flow.output.usedTools[0].toolOutput\nif(!toolOutput){\n  return {}\n}\n\nreturn {\n    \"listing_info\": toolOutput\n}",
          "updateStateMemoryUI": "[{\"key\":\"available_slots\",\"value\":\"$flow.output.usedTools[0].toolOutput\",\"actions\":\"\",\"id\":0}]"
        },
        "outputAnchors": [
          {
            "id": "seqAgent_0-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 879,
      "selected": false,
      "positionAbsolute": {
        "x": 1716.1824969880054,
        "y": -423.04930091714215
      },
      "dragging": false
    },
    {
      "id": "customTool_0",
      "position": {
        "x": 2127.320811962252,
        "y": -422.6616727821296
      },
      "type": "customNode",
      "data": {
        "id": "customTool_0",
        "label": "Custom Tool",
        "version": 2,
        "name": "customTool",
        "type": "CustomTool",
        "baseClasses": [
          "CustomTool",
          "Tool",
          "StructuredTool",
          "Runnable"
        ],
        "category": "Tools",
        "description": "Use custom tool you've created in Flowise within chatflow",
        "inputParams": [
          {
            "label": "Select Tool",
            "name": "selectedTool",
            "type": "asyncOptions",
            "loadMethod": "listTools",
            "id": "customTool_0-input-selectedTool-asyncOptions"
          },
          {
            "label": "Return Direct",
            "name": "returnDirect",
            "description": "Return the output of the tool directly to the user",
            "type": "boolean",
            "optional": true,
            "id": "customTool_0-input-returnDirect-boolean"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "selectedTool": "2b505fca-04a5-480c-9da0-73464cf023b5",
          "returnDirect": ""
        },
        "outputAnchors": [
          {
            "id": "customTool_0-output-customTool-CustomTool|Tool|StructuredTool|Runnable",
            "name": "customTool",
            "label": "CustomTool",
            "description": "Use custom tool you've created in Flowise within chatflow",
            "type": "CustomTool | Tool | StructuredTool | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 372,
      "selected": false,
      "positionAbsolute": {
        "x": 2127.320811962252,
        "y": -422.6616727821296
      },
      "dragging": false
    },
    {
      "id": "seqAgent_1",
      "position": {
        "x": 1711.9662531220238,
        "y": 481.20400229223674
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_1",
        "label": "Agent",
        "version": 4,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_1-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_1-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_1-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_1-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_1-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_1-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_1-input-tools-Tool"
          },
          {
            "label": "Start | Agent | Condition | LLM | Tool Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode",
            "list": true,
            "id": "seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_1-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "lead_capture",
          "systemMessagePrompt": "You are a lead capture agent for a property listing. Your primary goal is to gather potential buyer details, assign a score based on their  responses, and save the information in Airtable effectively.\n\nResponsibilities:\n1. Gather Lead Details:\n   - Ask the user for the following information:\n     - Name\n     - Email\n     - Budget (in USD)\n     - Additional comments or preferences related to the listing\n\n2. Ensure Data Accuracy:  \n   - Confirm the collected details with the user to ensure they are accurate before proceeding.\n\n3. Assign Lead Score:\n   - Based on the user’s responses and the context of the conversation, assign a lead score (‘cold,’ ‘warm,’ or ‘hot’) as per the instructions below.\n   - Do not disclose the assigned score to the user.\n\nLead Scoring Instructions:\n- Cold Lead:\n  - The lead has provided minimal details or has low buying intent.\n  - Indicators include:\n    - Budget is significantly below the property's price range.\n    - No additional comments or vague responses indicating indecisiveness.\n    - Reluctance to share contact details (e.g., email or phone).\n\n- Warm Lead:\n  - The lead shows moderate interest and provides sufficient information for follow-up.\n  - Indicators include:\n    - Budget is close to or slightly below the property's price range.\n    - They ask relevant questions about the property or show interest in specific features.\n    - Provide clear contact information (e.g., name, email, budget, additional notes).\n    - Additional comments indicate a general interest but no urgency (e.g., \"I’m exploring my options\").\n\n- Hot Lead:\n  - The lead exhibits high buying intent and is ready for immediate action.\n  - Indicators include:\n    - Budget is close to or within or above the property's price range.\n    - They ask detailed questions, express urgency, or inquire about next steps (e.g., scheduling a viewing or finalizing details).\n    - Provide complete contact information and respond positively to follow-up queries.\n    - Additional comments indicate clear readiness to proceed (e.g., \"I’m ready to buy within a month\").\n\nScoring Workflow:\n- Use the lead's responses to assign a score based on the criteria above.\n- Ensure the score reflects their level of interest and readiness to proceed.\n\n4. Save Lead Details:\n   - Once the user confirms their information, go ahead and make sure to save the lead details (including the assigned score) into the Airtable database. This step is mandatory.\n\n5. Communication:\n   - Be polite, professional, and clear in your communication, focusing solely on capturing and saving lead details.",
          "messageHistory": "",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "",
          "tools": [
            "{{customTool_1.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqConditionAgent_0.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": ""
        },
        "outputAnchors": [
          {
            "id": "seqAgent_1-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 879,
      "selected": false,
      "positionAbsolute": {
        "x": 1711.9662531220238,
        "y": 481.20400229223674
      },
      "dragging": false
    },
    {
      "id": "customTool_1",
      "position": {
        "x": 2073.736995481761,
        "y": 486.36174868034686
      },
      "type": "customNode",
      "data": {
        "id": "customTool_1",
        "label": "Custom Tool",
        "version": 2,
        "name": "customTool",
        "type": "CustomTool",
        "baseClasses": [
          "CustomTool",
          "Tool",
          "StructuredTool",
          "Runnable"
        ],
        "category": "Tools",
        "description": "Use custom tool you've created in Flowise within chatflow",
        "inputParams": [
          {
            "label": "Select Tool",
            "name": "selectedTool",
            "type": "asyncOptions",
            "loadMethod": "listTools",
            "id": "customTool_1-input-selectedTool-asyncOptions"
          },
          {
            "label": "Return Direct",
            "name": "returnDirect",
            "description": "Return the output of the tool directly to the user",
            "type": "boolean",
            "optional": true,
            "id": "customTool_1-input-returnDirect-boolean"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "selectedTool": "a1af2447-bf1b-4660-9168-c0e701bc1bdf",
          "returnDirect": ""
        },
        "outputAnchors": [
          {
            "id": "customTool_1-output-customTool-CustomTool|Tool|StructuredTool|Runnable",
            "name": "customTool",
            "label": "CustomTool",
            "description": "Use custom tool you've created in Flowise within chatflow",
            "type": "CustomTool | Tool | StructuredTool | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 372,
      "selected": false,
      "positionAbsolute": {
        "x": 2073.736995481761,
        "y": 486.36174868034686
      },
      "dragging": false
    },
    {
      "id": "seqAgent_2",
      "position": {
        "x": 1705.5240174445776,
        "y": 1386.0495492362522
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_2",
        "label": "Agent",
        "version": 4,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_2-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_2-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 🦜 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_2-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_2-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_2-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_2-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_2-input-tools-Tool"
          },
          {
            "label": "Start | Agent | Condition | LLM | Tool Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode",
            "list": true,
            "id": "seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_2-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "payment_calculation",
          "systemMessagePrompt": "You are a financial assistant specializing in helping users calculate only monthly payments (EMI) for this property listing. Your role is to gather and validate the following inputs one by one from the user:\n\n1. Desired Down Payment Percentage (must be between 20% and 90%).  \n2. Desired Loan Term (must be between 10 years and 30 years).  \n3. Desired Interest Rate (must be between 3% and 10%).\n\nSteps to Calculate EMI:\n1. Calculate the Loan Amount:\n   Loan Amount (P) = Property Listing Price × (1 - (Down Payment Percentage / 100))\n\n2. Calculate EMI (Monthly Payment):\n   EMI = [P × r × (1 + r)^N] / [(1 + r)^N - 1]\n\n   Where:\n   - P is the Loan Amount calculated in Step 1.\n   - r is the Monthly Interest Rate:\n     r = (Annual Interest Rate) / (12 × 100)\n   - N is the Total Number of Monthly Payments:\n     N = Loan Term (in years) × 12\n\nResponsibilities:\n- Validate user inputs to ensure they are within the specified ranges.\n- If listing price is not provided, get it from database. Do not ask user explicitly. But make sure you have gathered all other input variables before retrieving listing price details.\n- Only provide a clear breakdown of the input values and the final EMI amount in the response. Do not include any other  property details in the response.\n- Address any user questions regarding the calculation politely, but ensure the focus remains strictly on financial computations related to the property listing.  \n- Avoid answering questions outside the scope of EMI calculations or property-specific financial discussions.",
          "messageHistory": "",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "listing details: {listing_details}",
          "tools": [
            "{{calculator_0.data.instance}}",
            "{{customTool_0.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqConditionAgent_0.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "{\"listing_details\":\"$flow.state.listing_info\"}",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": "",
          "updateStateMemoryUI": "[]",
          "selectedUpdateStateMemoryTab_seqAgent_2": "updateStateMemoryCode",
          "updateStateMemoryCode": "const isToolsUsed = $flow.output.usedTools?.length\nif(!isToolsUsed){\n  return {}\n}\n\nconst airtableToolUsed = $flow.output.usedTools?.find(t => t.tool === 'get_listing_from_airtable')\nif(!airtableToolUsed){\n  return {}\n}\n\nconsole.log(\"INSIDE CALCULATION STATE PDATE : \", airtableToolUsed)\n\nreturn {\n    \"listing_info\": airtableToolUsed.toolOutput\n}"
        },
        "outputAnchors": [
          {
            "id": "seqAgent_2-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 879,
      "selected": false,
      "positionAbsolute": {
        "x": 1705.5240174445776,
        "y": 1386.0495492362522
      },
      "dragging": false
    },
    {
      "id": "calculator_0",
      "position": {
        "x": 2054.434311764799,
        "y": 1394.6866589265694
      },
      "type": "customNode",
      "data": {
        "id": "calculator_0",
        "label": "Calculator",
        "version": 1,
        "name": "calculator",
        "type": "Calculator",
        "baseClasses": [
          "Calculator",
          "Tool",
          "StructuredTool",
          "Runnable"
        ],
        "category": "Tools",
        "description": "Perform calculations on response",
        "inputParams": [],
        "inputAnchors": [],
        "inputs": {},
        "outputAnchors": [
          {
            "id": "calculator_0-output-calculator-Calculator|Tool|StructuredTool|Runnable",
            "name": "calculator",
            "label": "Calculator",
            "description": "Perform calculations on response",
            "type": "Calculator | Tool | StructuredTool | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 143,
      "selected": false,
      "positionAbsolute": {
        "x": 2054.434311764799,
        "y": 1394.6866589265694
      },
      "dragging": false
    },
    {
      "id": "seqEnd_2",
      "position": {
        "x": 2062.001590056177,
        "y": 1212.257853742053
      },
      "type": "customNode",
      "data": {
        "id": "seqEnd_2",
        "label": "End",
        "version": 2,
        "name": "seqEnd",
        "type": "End",
        "baseClasses": [
          "End"
        ],
        "category": "Sequential Agents",
        "description": "End conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Agent | Condition | LLM | Tool Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode",
            "id": "seqEnd_2-input-sequentialNode-Agent | Condition | LLMNode | ToolNode"
          }
        ],
        "inputs": {
          "sequentialNode": "{{seqAgent_1.data.instance}}"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 143,
      "selected": false,
      "positionAbsolute": {
        "x": 2062.001590056177,
        "y": 1212.257853742053
      },
      "dragging": false
    },
    {
      "id": "seqEnd_3",
      "position": {
        "x": 2078.1229717254705,
        "y": 2124.2258710582646
      },
      "type": "customNode",
      "data": {
        "id": "seqEnd_3",
        "label": "End",
        "version": 2,
        "name": "seqEnd",
        "type": "End",
        "baseClasses": [
          "End"
        ],
        "category": "Sequential Agents",
        "description": "End conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Agent | Condition | LLM | Tool Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode",
            "id": "seqEnd_3-input-sequentialNode-Agent | Condition | LLMNode | ToolNode"
          }
        ],
        "inputs": {
          "sequentialNode": "{{seqAgent_2.data.instance}}"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 143,
      "selected": false,
      "positionAbsolute": {
        "x": 2078.1229717254705,
        "y": 2124.2258710582646
      },
      "dragging": false
    },
    {
      "id": "seqEnd_0",
      "position": {
        "x": 2158.5240201174215,
        "y": 312.4794182134591
      },
      "type": "customNode",
      "data": {
        "id": "seqEnd_0",
        "label": "End",
        "version": 2,
        "name": "seqEnd",
        "type": "End",
        "baseClasses": [
          "End"
        ],
        "category": "Sequential Agents",
        "description": "End conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Agent | Condition | LLM | Tool Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode",
            "id": "seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode"
          }
        ],
        "inputs": {
          "sequentialNode": "{{seqAgent_0.data.instance}}"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 143,
      "selected": false,
      "positionAbsolute": {
        "x": 2158.5240201174215,
        "y": 312.4794182134591
      },
      "dragging": false
    }
  ],
  "edges": [
    {
      "source": "chatOpenAI_0",
      "sourceHandle": "chatOpenAI_0-output-chatOpenAI-ChatOpenAI|BaseChatModel|BaseLanguageModel|Runnable",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-model-BaseChatModel",
      "type": "buttonedge",
      "id": "chatOpenAI_0-chatOpenAI_0-output-chatOpenAI-ChatOpenAI|BaseChatModel|BaseLanguageModel|Runnable-seqStart_0-seqStart_0-input-model-BaseChatModel"
    },
    {
      "source": "seqState_0",
      "sourceHandle": "seqState_0-output-seqState-State",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-state-State",
      "type": "buttonedge",
      "id": "seqState_0-seqState_0-output-seqState-State-seqStart_0-seqStart_0-input-state-State"
    },
    {
      "source": "mySQLAgentMemory_0",
      "sourceHandle": "mySQLAgentMemory_0-output-mySQLAgentMemory-AgentMemory|BaseCheckpointSaver",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-agentMemory-BaseCheckpointSaver",
      "type": "buttonedge",
      "id": "mySQLAgentMemory_0-mySQLAgentMemory_0-output-mySQLAgentMemory-AgentMemory|BaseCheckpointSaver-seqStart_0-seqStart_0-input-agentMemory-BaseCheckpointSaver"
    },
    {
      "source": "seqStart_0",
      "sourceHandle": "seqStart_0-output-seqStart-Start",
      "target": "seqConditionAgent_0",
      "targetHandle": "seqConditionAgent_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode",
      "type": "buttonedge",
      "id": "seqStart_0-seqStart_0-output-seqStart-Start-seqConditionAgent_0-seqConditionAgent_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode"
    },
    {
      "source": "seqConditionAgent_0",
      "sourceHandle": "seqConditionAgent_0-output-listingDetails-Condition",
      "target": "seqAgent_0",
      "targetHandle": "seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode",
      "type": "buttonedge",
      "id": "seqConditionAgent_0-seqConditionAgent_0-output-listingDetails-Condition-seqAgent_0-seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode"
    },
    {
      "source": "customTool_0",
      "sourceHandle": "customTool_0-output-customTool-CustomTool|Tool|StructuredTool|Runnable",
      "target": "seqAgent_0",
      "targetHandle": "seqAgent_0-input-tools-Tool",
      "type": "buttonedge",
      "id": "customTool_0-customTool_0-output-customTool-CustomTool|Tool|StructuredTool|Runnable-seqAgent_0-seqAgent_0-input-tools-Tool"
    },
    {
      "source": "seqConditionAgent_0",
      "sourceHandle": "seqConditionAgent_0-output-leadCapture-Condition",
      "target": "seqAgent_1",
      "targetHandle": "seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode",
      "type": "buttonedge",
      "id": "seqConditionAgent_0-seqConditionAgent_0-output-leadCapture-Condition-seqAgent_1-seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode"
    },
    {
      "source": "seqConditionAgent_0",
      "sourceHandle": "seqConditionAgent_0-output-paymentCalculation-Condition",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode",
      "type": "buttonedge",
      "id": "seqConditionAgent_0-seqConditionAgent_0-output-paymentCalculation-Condition-seqAgent_2-seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode"
    },
    {
      "source": "calculator_0",
      "sourceHandle": "calculator_0-output-calculator-Calculator|Tool|StructuredTool|Runnable",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-tools-Tool",
      "type": "buttonedge",
      "id": "calculator_0-calculator_0-output-calculator-Calculator|Tool|StructuredTool|Runnable-seqAgent_2-seqAgent_2-input-tools-Tool"
    },
    {
      "source": "customTool_0",
      "sourceHandle": "customTool_0-output-customTool-CustomTool|Tool|StructuredTool|Runnable",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-tools-Tool",
      "type": "buttonedge",
      "id": "customTool_0-customTool_0-output-customTool-CustomTool|Tool|StructuredTool|Runnable-seqAgent_2-seqAgent_2-input-tools-Tool"
    },
    {
      "source": "seqAgent_1",
      "sourceHandle": "seqAgent_1-output-seqAgent-Agent",
      "target": "seqEnd_2",
      "targetHandle": "seqEnd_2-input-sequentialNode-Agent | Condition | LLMNode | ToolNode",
      "type": "buttonedge",
      "id": "seqAgent_1-seqAgent_1-output-seqAgent-Agent-seqEnd_2-seqEnd_2-input-sequentialNode-Agent | Condition | LLMNode | ToolNode"
    },
    {
      "source": "seqAgent_2",
      "sourceHandle": "seqAgent_2-output-seqAgent-Agent",
      "target": "seqEnd_3",
      "targetHandle": "seqEnd_3-input-sequentialNode-Agent | Condition | LLMNode | ToolNode",
      "type": "buttonedge",
      "id": "seqAgent_2-seqAgent_2-output-seqAgent-Agent-seqEnd_3-seqEnd_3-input-sequentialNode-Agent | Condition | LLMNode | ToolNode"
    },
    {
      "source": "customTool_1",
      "sourceHandle": "customTool_1-output-customTool-CustomTool|Tool|StructuredTool|Runnable",
      "target": "seqAgent_1",
      "targetHandle": "seqAgent_1-input-tools-Tool",
      "type": "buttonedge",
      "id": "customTool_1-customTool_1-output-customTool-CustomTool|Tool|StructuredTool|Runnable-seqAgent_1-seqAgent_1-input-tools-Tool"
    },
    {
      "source": "seqConditionAgent_0",
      "sourceHandle": "seqConditionAgent_0-output-end-Condition",
      "target": "seqAgent_0",
      "targetHandle": "seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode",
      "type": "buttonedge",
      "id": "seqConditionAgent_0-seqConditionAgent_0-output-end-Condition-seqAgent_0-seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode"
    },
    {
      "source": "seqAgent_0",
      "sourceHandle": "seqAgent_0-output-seqAgent-Agent",
      "target": "seqEnd_0",
      "targetHandle": "seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode",
      "type": "buttonedge",
      "id": "seqAgent_0-seqAgent_0-output-seqAgent-Agent-seqEnd_0-seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode"
    }
  ]
}